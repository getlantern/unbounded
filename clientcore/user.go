// user.go provides a facility for proxying user-generated bytestreams - ie, streams which
// originate from a process running on the user's computer (like a web browser) or streams which
// are generated as part of the user's Lantern control plane activity. We can operationalize a
// user stream in a WorkerFSM just like we do an RTCPeerConnection or a websocket.Conn, such that
// bytestreams from the user can be neatly managed alongside bytestreams from remote peers in
// their consumer table. In other words: we treat the user's web browser just like any connected consumer.
package clientcore

import (
	"context"
	"fmt"
	"io"
	"net"
	"sync"
	"time"

	"github.com/google/uuid"

	"github.com/getlantern/broflake/common"
)

type BroflakeConn struct {
	writeChan          chan IPCMsg
	readChan           chan IPCMsg
	localAddr          common.DebugAddr
	remoteAddr         common.DebugAddr
	readDeadline       time.Time
	updateReadDeadline chan time.Time

	closeOnce sync.Once
}

func (c *BroflakeConn) LocalAddr() net.Addr {
	return c.localAddr
}

func (c *BroflakeConn) ReadFrom(p []byte) (n int, addr net.Addr, err error) {
	for {
		var ctx context.Context

		// If the deadline is zero value, never expire; otherwise obey the deadline
		if c.readDeadline.IsZero() {
			ctx, _ = context.WithCancel(context.Background())
		} else {
			var cancel context.CancelFunc
			ctx, cancel = context.WithDeadline(context.Background(), c.readDeadline)
			defer cancel()
		}

		select {
		case msg, ok := <-c.readChan:
			if !ok {
				return 0, c.remoteAddr, io.EOF
			}

			// The read completed, let's return some bytes!
			payload, ok := msg.Data.([]byte)
			if !ok {
				return 0, c.remoteAddr, fmt.Errorf("wrong type of IPC message: %T", msg.Data)
			}
			copy(p, payload)
			return len(payload), c.remoteAddr, nil
		case <-ctx.Done():
			// We're past our deadline, so let's return failure!
			return 0, c.remoteAddr, ctx.Err()
		case d := <-c.updateReadDeadline:
			// Someone updated the read deadline, so let's iterate to respect the new deadline
			c.readDeadline = d
		}
	}
}

func (c *BroflakeConn) WriteTo(p []byte, addr net.Addr) (n int, err error) {
	// TODO: This copy seems necessary to avoid a data race
	b := make([]byte, len(p))
	copy(b, p)

	select {
	case c.writeChan <- IPCMsg{IpcType: ChunkIPC, Data: b}:
		// Do nothing, message sent
	default:
		// Drop the chunk if we can't keep up with the data rate
		return 0, fmt.Errorf("dropped chunk")
	}

	return len(b), nil
}

// XXX: A note about deadlines: as of quic-go 0.34, the QUIC dialer didn't seem to care about read
// or write deadlines, and it was happy to use a net.PacketConn which didn't properly implement them.
// But when we bumped to quic-go 0.40, it emerged that the dialer wouldn't work unless we added
// support for read deadlines. Since there's still no evidence that the dialer cares about write
// deadlines, we haven't added support for those yet.
func (c *BroflakeConn) SetReadDeadline(t time.Time) error {
	c.updateReadDeadline <- t
	return nil
}

func (c *BroflakeConn) SetWriteDeadline(t time.Time) error { return nil }
func (c *BroflakeConn) SetDeadline(t time.Time) error      { return c.SetReadDeadline(t) }

func (c *BroflakeConn) Close() error {
	c.closeOnce.Do(func() {
		close(c.writeChan)
		close(c.readChan)
	})
	return nil
}

func NewProducerUserStream(wg *sync.WaitGroup) (*BroflakeConn, *WorkerFSM) {
	worker := NewWorkerFSM(wg, []FSMstate{
		FSMstate(func(ctx context.Context, com *ipcChan, input []interface{}) (int, []interface{}) {
			// State 0
			// (no input data)
			common.Debugf("User stream producer state 0...")
			// TODO: check for a non-nil path assertion to alert the UI that we're ready to proxy?

			<-ctx.Done()
			return 0, nil
		}),
	})

	bfconn := BroflakeConn{
		writeChan:          worker.com.tx,
		readChan:           worker.com.rx,
		localAddr:          common.DebugAddr(uuid.NewString()),
		remoteAddr:         common.DebugAddr(uuid.NewString()),
		readDeadline:       time.Time{},
		updateReadDeadline: make(chan time.Time, 512),
	}

	return &bfconn, worker
}

func NewConsumerUserStream(wg *sync.WaitGroup) (*BroflakeConn, *WorkerFSM) {
	worker := NewWorkerFSM(wg, []FSMstate{
		FSMstate(func(ctx context.Context, com *ipcChan, input []interface{}) (int, []interface{}) {
			// State 0
			// (no input data)
			common.Debugf("User stream consumer state 0...")

			// Send a path assertion IPC message representing the connectivity now provided by this slot
			allowAll := []common.Endpoint{{Host: "*", Distance: 1}}
			com.tx <- IPCMsg{IpcType: PathAssertionIPC, Data: common.PathAssertion{Allow: allowAll}}

			<-ctx.Done()
			return 0, nil
		}),
	})

	bfconn := BroflakeConn{
		writeChan:          worker.com.tx,
		readChan:           worker.com.rx,
		localAddr:          common.DebugAddr(uuid.NewString()),
		remoteAddr:         common.DebugAddr(uuid.NewString()),
		readDeadline:       time.Time{},
		updateReadDeadline: make(chan time.Time, 512),
	}

	return &bfconn, worker
}
