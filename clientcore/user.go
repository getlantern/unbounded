// user.go provides a facility for proxying user-generated bytestreams - ie, streams which
// originate from a process running on the user's computer (like a web browser) or streams which
// are generated as part of the user's Lantern control plane activity. We can operationalize a
// user stream in a WorkerFSM just like we do an RTCPeerConnection or a websocket.Conn, such that
// bytestreams from the user can be neatly managed alongside bytestreams from remote peers in
// their consumer table. In other words: we treat the user's web browser just like any connected consumer.
package clientcore

import (
	"context"
	"encoding/json"
	"net"
	"sync"
	"time"

	"github.com/google/uuid"

	"github.com/getlantern/broflake/common"
)

type BroflakeConn struct {
	writeChan          chan IPCMsg
	readChan           chan IPCMsg
	addr               common.DebugAddr
	readDeadline       time.Time
	updateReadDeadline chan time.Time
}

func (c BroflakeConn) LocalAddr() net.Addr {
	return c.addr
}

func (c BroflakeConn) ReadFrom(p []byte) (n int, addr net.Addr, err error) {
	for {
		var ctx context.Context

		// If the deadline is zero value, never expire; otherwise obey the deadline
		if c.readDeadline.IsZero() {
			ctx, _ = context.WithCancel(context.Background())
		} else {
			ctx, _ = context.WithDeadline(context.Background(), c.readDeadline)
		}

		select {
		case msg := <-c.readChan:
			// The read completed, let's return some bytes!
			payload := msg.Data.([]byte)

			var unboundedPacket common.UnboundedPacket

			err := json.Unmarshal(payload, &unboundedPacket)
			if err != nil {
				// XXX: it's unclear what the desired behavior is here. Before the introduction of
				// UnboundedPacket, there was no precedent for returning an error after successfully reading
				// from the channel. Returning an error here may break things catastrophically, but if
				// we couldn't unmarshal the packet, we do have a catastrophic situation on our hands...
				return 0, nil, err
			}

			copy(p, unboundedPacket.Payload)
			return len(unboundedPacket.Payload), common.DebugAddr(unboundedPacket.SourceAddr), nil
		case <-ctx.Done():
			// We're past our deadline, so let's return failure!
			// TODO: you can't return NELSON WUZ HERE here
			return 0, common.DebugAddr("NELSON WUZ HERE"), ctx.Err()
		case d := <-c.updateReadDeadline:
			// Someone updated the read deadline, so let's iterate to respect the new deadline
			c.readDeadline = d
		}
	}
}

func (c BroflakeConn) WriteTo(p []byte, addr net.Addr) (n int, err error) {
	// TODO: This copy seems necessary to avoid a data race
	b := make([]byte, len(p))
	copy(b, p)

	select {
	case c.writeChan <- IPCMsg{IpcType: ChunkIPC, Data: b}:
		// Do nothing, message sent
	default:
		// Drop the chunk if we can't keep up with the data rate
	}

	return len(b), nil
}

func (c BroflakeConn) Close() error {
	return nil
}

// XXX: A note about deadlines: as of quic-go 0.34, the QUIC dialer didn't seem to care about read
// or write deadlines, and it was happy to use a net.PacketConn which didn't properly implement them.
// But when we bumped to quic-go 0.40, it emerged that the dialer wouldn't work unless we added
// support for read deadlines. Since there's still no evidence that the dialer cares about write
// deadlines, we haven't added support for those yet.
func (c BroflakeConn) SetReadDeadline(t time.Time) error {
	c.updateReadDeadline <- t
	return nil
}

func (c BroflakeConn) SetWriteDeadline(t time.Time) error {
	return nil
}

func (c BroflakeConn) SetDeadline(t time.Time) error {
	return nil
}
func NewProducerUserStream(wg *sync.WaitGroup) (*BroflakeConn, *WorkerFSM) {
	worker := NewWorkerFSM(wg, []FSMstate{
		FSMstate(func(ctx context.Context, com *ipcChan, input []interface{}) (int, []interface{}) {
			// State 0
			// (no input data)
			common.Debugf("User stream producer state 0...")
			// TODO: check for a non-nil path assertion to alert the UI that we're ready to proxy?
			select {}
		}),
	})

	bfconn := BroflakeConn{
		writeChan:          worker.com.tx,
		readChan:           worker.com.rx,
		addr:               common.DebugAddr(uuid.NewString()),
		readDeadline:       time.Time{},
		updateReadDeadline: make(chan time.Time, 512),
	}

	return &bfconn, worker
}
